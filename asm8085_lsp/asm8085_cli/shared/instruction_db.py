"""Detailed metadata for Intel 8085 instructions."""

INSTRUCTION_DB = {
    # Data Transfer Instructions
    "MOV": {
        "name": "MOV (Move Register to Register)",
        "opcode_base": "01DDDSSS",
        "example_opcode": "7F (MOV A, A) = 01111111₂",
        "size": 1,
        "cycles": {"reg": 4, "mem": 7},
        "flags": "None",
        "description": "Copy data from source register to destination register",
        "syntax": "MOV dest, source",
        "example": "MOV B, A    ; Copy A to B\nMOV M, C    ; Store C at memory location [HL]",
        "notes": "MOV M, M is invalid (HLT instruction)",
        "related": ["MVI", "LDA", "STA"],
    },
    "MVI": {
        "name": "MVI (Move Immediate)",
        "opcode_base": "00DDD110",
        "example_opcode": "3E (MVI A) = 00111110₂",
        "size": 2,
        "cycles": {"reg": 7, "mem": 10},
        "flags": "None",
        "description": "Load an 8-bit immediate value into a register",
        "syntax": "MVI register, data",
        "example": "MVI A, 05H  ; Load 05H into A\nMVI B, FFH  ; Load FFH into B\nMVI M, 42H  ; Store 42H at [HL]",
        "notes": "Most common way to initialize registers",
        "related": ["MOV", "LXI"],
    },
    "LXI": {
        "name": "LXI (Load Register Pair Immediate)",
        "opcode_base": "00RP0001",
        "example_opcode": "21 (LXI H) = 00100001₂",
        "size": 3,
        "cycles": {"any": 10},
        "flags": "None",
        "description": "Load 16-bit immediate value into register pair",
        "syntax": "LXI pair, data16",
        "example": "LXI H, 1000H  ; HL = 1000H\nLXI B, 0050H  ; BC = 0050H\nLXI SP, FFFFH ; SP = FFFFH",
        "notes": "Lower byte loaded first, then upper byte",
        "related": ["MVI", "LHLD"],
    },
    "LDA": {
        "name": "LDA (Load Accumulator Direct)",
        "opcode_base": "00111010",
        "example_opcode": "3A = 00111010₂",
        "size": 3,
        "cycles": {"any": 13},
        "flags": "None",
        "description": "Load accumulator from memory at 16-bit address",
        "syntax": "LDA address",
        "example": "LDA 2050H   ; A = [2050H]\nLDA 1000H   ; A = [1000H]",
        "notes": "Direct addressing - address specified in instruction",
        "related": ["STA", "LDAX", "MOV A, M"],
    },
    "STA": {
        "name": "STA (Store Accumulator Direct)",
        "opcode_base": "00110010",
        "example_opcode": "32 = 00110010₂",
        "size": 3,
        "cycles": {"any": 13},
        "flags": "None",
        "description": "Store accumulator to memory at 16-bit address",
        "syntax": "STA address",
        "example": "STA 2050H   ; [2050H] = A\nSTA 1000H   ; [1000H] = A",
        "notes": "Direct addressing - address specified in instruction",
        "related": ["LDA", "STAX", "MOV M, A"],
    },
    "LDAX": {
        "name": "LDAX (Load Accumulator Indirect)",
        "opcode_base": "000RP010 (RP=BC or DE)",
        "example_opcode": "0A (LDAX B) = 00001010₂",
        "size": 1,
        "cycles": {"any": 7},
        "flags": "None",
        "description": "Load accumulator from address in BC or DE pair",
        "syntax": "LDAX B/D",
        "example": "LDAX B      ; A = [BC]\nLDAX D      ; A = [DE]",
        "notes": "Only works with BC or DE pairs, not HL",
        "related": ["STAX", "LDA", "MOV A, M"],
    },
    "STAX": {
        "name": "STAX (Store Accumulator Indirect)",
        "opcode_base": "000RP010 (RP=BC or DE)",
        "example_opcode": "02 (STAX B) = 00000010₂",
        "size": 1,
        "cycles": {"any": 7},
        "flags": "None",
        "description": "Store accumulator to address in BC or DE pair",
        "syntax": "STAX B/D",
        "example": "STAX B      ; [BC] = A\nSTAX D      ; [DE] = A",
        "notes": "Only works with BC or DE pairs, not HL",
        "related": ["LDAX", "STA", "MOV M, A"],
    },
    "LHLD": {
        "name": "LHLD (Load HL Direct)",
        "opcode_base": "00101010",
        "example_opcode": "2A = 00101010₂",
        "size": 3,
        "cycles": {"any": 16},
        "flags": "None",
        "description": "Load HL register pair from memory",
        "syntax": "LHLD address",
        "example": "LHLD 2050H  ; L=[2050H], H=[2051H]",
        "notes": "Loads 2 bytes: L from addr, H from addr+1",
        "related": ["SHLD", "LXI H"],
    },
    "SHLD": {
        "name": "SHLD (Store HL Direct)",
        "opcode_base": "00100010",
        "example_opcode": "22 = 00100010₂",
        "size": 3,
        "cycles": {"any": 16},
        "flags": "None",
        "description": "Store HL register pair to memory",
        "syntax": "SHLD address",
        "example": "SHLD 2050H  ; [2050H]=L, [2051H]=H",
        "notes": "Stores 2 bytes: L to addr, H to addr+1",
        "related": ["LHLD", "SPHL"],
    },
    "XCHG": {
        "name": "XCHG (Exchange HL and DE)",
        "opcode_base": "11101011",
        "example_opcode": "EB = 11101011₂",
        "size": 1,
        "cycles": {"any": 4},
        "flags": "None",
        "description": "Exchange contents of HL and DE pairs",
        "syntax": "XCHG",
        "example": "XCHG        ; H↔D, L↔E",
        "notes": "Fast register pair swap (4 cycles)",
        "related": ["XTHL", "SPHL"],
    },
    "SPHL": {
        "name": "SPHL (Move HL to SP)",
        "opcode_base": "11111001",
        "example_opcode": "F9 = 11111001₂",
        "size": 1,
        "cycles": {"any": 6},
        "flags": "None",
        "description": "Copy HL to stack pointer",
        "syntax": "SPHL",
        "example": "SPHL        ; SP = HL",
        "notes": "Used to set up custom stack locations",
        "related": ["LXI SP", "XCHG"],
    },
    "XTHL": {
        "name": "XTHL (Exchange Stack Top with HL)",
        "opcode_base": "11100011",
        "example_opcode": "E3 = 11100011₂",
        "size": 1,
        "cycles": {"any": 16},
        "flags": "None",
        "description": "Exchange HL with top of stack",
        "syntax": "XTHL",
        "example": "XTHL        ; L↔[SP], H↔[SP+1]",
        "notes": "Stack pointer unchanged, useful for parameter passing",
        "related": ["XCHG", "POP H", "PUSH H"],
    },
    "PCHL": {
        "name": "PCHL (Move HL to PC)",
        "opcode_base": "11101001",
        "example_opcode": "E9 = 11101001₂",
        "size": 1,
        "cycles": {"any": 6},
        "flags": "None",
        "description": "Jump to address in HL register pair",
        "syntax": "PCHL",
        "example": "PCHL        ; PC = HL",
        "notes": "Fast computed jump, useful for jump tables",
        "related": ["JMP", "SPHL"],
    },
    # Arithmetic Instructions
    "ADD": {
        "name": "ADD (Add Register to Accumulator)",
        "opcode_base": "10000SSS",
        "example_opcode": "80 (ADD B) = 10000000₂",
        "size": 1,
        "cycles": {"reg": 4, "mem": 7},
        "flags": "S, Z, AC, P, CY",
        "description": "Add register or memory to accumulator",
        "syntax": "ADD register",
        "example": "ADD B       ; A = A + B\nADD M       ; A = A + [HL]",
        "notes": "All flags affected. Use for unsigned addition",
        "related": ["ADI", "ADC", "SUB"],
    },
    "ADI": {
        "name": "ADI (Add Immediate to Accumulator)",
        "opcode_base": "11000110",
        "example_opcode": "C6 = 11000110₂",
        "size": 2,
        "cycles": {"any": 7},
        "flags": "S, Z, AC, P, CY",
        "description": "Add 8-bit immediate data to accumulator",
        "syntax": "ADI data",
        "example": "ADI 05H     ; A = A + 05H\nADI FFH     ; A = A + FFH",
        "notes": "Convenient for constants. All flags affected",
        "related": ["ADD", "ACI", "SUI"],
    },
    "SUB": {
        "name": "SUB (Subtract Register from Accumulator)",
        "opcode_base": "10010SSS",
        "example_opcode": "90 (SUB B) = 10010000₂",
        "size": 1,
        "cycles": {"reg": 4, "mem": 7},
        "flags": "S, Z, AC, P, CY",
        "description": "Subtract register or memory from accumulator",
        "syntax": "SUB register",
        "example": "SUB B       ; A = A - B\nSUB M       ; A = A - [HL]",
        "notes": "CY set if borrow required",
        "related": ["SUI", "SBB", "CMP"],
    },
    "INR": {
        "name": "INR (Increment Register)",
        "opcode_base": "00DDD100",
        "example_opcode": "3C (INR A) = 00111100₂",
        "size": 1,
        "cycles": {"reg": 4, "mem": 10},
        "flags": "S, Z, AC, P (CY not affected)",
        "description": "Increment register or memory by 1",
        "syntax": "INR register",
        "example": "INR A       ; A = A + 1\nINR B       ; B = B + 1\nINR M       ; [HL] = [HL] + 1",
        "notes": "Carry flag NOT affected - useful for loop counters",
        "related": ["DCR", "INX"],
    },
    "DCR": {
        "name": "DCR (Decrement Register)",
        "opcode_base": "00DDD101",
        "example_opcode": "3D (DCR A) = 00111101₂",
        "size": 1,
        "cycles": {"reg": 4, "mem": 10},
        "flags": "S, Z, AC, P (CY not affected)",
        "description": "Decrement register or memory by 1",
        "syntax": "DCR register",
        "example": "DCR A       ; A = A - 1\nDCR B       ; B = B - 1\nDCR M       ; [HL] = [HL] - 1",
        "notes": "Carry flag NOT affected - useful for loop counters",
        "related": ["INR", "DCX"],
    },
    "ADC": {
        "name": "ADC (Add with Carry)",
        "opcode_base": "10001SSS",
        "example_opcode": "88 (ADC B) = 10001000₂",
        "size": 1,
        "cycles": {"reg": 4, "mem": 7},
        "flags": "S, Z, AC, P, CY",
        "description": "Add register and carry flag to accumulator",
        "syntax": "ADC register",
        "example": "ADC B       ; A = A + B + CY\nADC M       ; A = A + [HL] + CY",
        "notes": "Essential for multi-byte addition",
        "related": ["ADD", "ACI", "SBB"],
    },
    "ACI": {
        "name": "ACI (Add Immediate with Carry)",
        "opcode_base": "11001110",
        "example_opcode": "CE = 11001110₂",
        "size": 2,
        "cycles": {"any": 7},
        "flags": "S, Z, AC, P, CY",
        "description": "Add immediate data and carry to accumulator",
        "syntax": "ACI data",
        "example": "ACI 05H     ; A = A + 05H + CY",
        "notes": "Used in multi-byte addition with constants",
        "related": ["ADI", "ADC", "SBI"],
    },
    "SBB": {
        "name": "SBB (Subtract with Borrow)",
        "opcode_base": "10011SSS",
        "example_opcode": "98 (SBB B) = 10011000₂",
        "size": 1,
        "cycles": {"reg": 4, "mem": 7},
        "flags": "S, Z, AC, P, CY",
        "description": "Subtract register and carry from accumulator",
        "syntax": "SBB register",
        "example": "SBB B       ; A = A - B - CY\nSBB M       ; A = A - [HL] - CY",
        "notes": "Essential for multi-byte subtraction",
        "related": ["SUB", "SBI", "ADC"],
    },
    "SBI": {
        "name": "SBI (Subtract Immediate with Borrow)",
        "opcode_base": "11011110",
        "example_opcode": "DE = 11011110₂",
        "size": 2,
        "cycles": {"any": 7},
        "flags": "S, Z, AC, P, CY",
        "description": "Subtract immediate data and carry from accumulator",
        "syntax": "SBI data",
        "example": "SBI 05H     ; A = A - 05H - CY",
        "notes": "Used in multi-byte subtraction with constants",
        "related": ["SUI", "SBB", "ACI"],
    },
    "SUI": {
        "name": "SUI (Subtract Immediate)",
        "opcode_base": "11010110",
        "example_opcode": "D6 = 11010110₂",
        "size": 2,
        "cycles": {"any": 7},
        "flags": "S, Z, AC, P, CY",
        "description": "Subtract immediate data from accumulator",
        "syntax": "SUI data",
        "example": "SUI 05H     ; A = A - 05H",
        "notes": "Convenient for constants",
        "related": ["SUB", "SBI", "ADI"],
    },
    "INX": {
        "name": "INX (Increment Register Pair)",
        "opcode_base": "00RP0011",
        "example_opcode": "03 (INX B) = 00000011₂",
        "size": 1,
        "cycles": {"any": 6},
        "flags": "None",
        "description": "Increment 16-bit register pair by 1",
        "syntax": "INX pair",
        "example": "INX B       ; BC = BC + 1\nINX H       ; HL = HL + 1",
        "notes": "No flags affected, useful for address pointers",
        "related": ["DCX", "INR"],
    },
    "DCX": {
        "name": "DCX (Decrement Register Pair)",
        "opcode_base": "00RP1011",
        "example_opcode": "0B (DCX B) = 00001011₂",
        "size": 1,
        "cycles": {"any": 6},
        "flags": "None",
        "description": "Decrement 16-bit register pair by 1",
        "syntax": "DCX pair",
        "example": "DCX B       ; BC = BC - 1\nDCX H       ; HL = HL - 1",
        "notes": "No flags affected, useful for counting down",
        "related": ["INX", "DCR"],
    },
    "DAD": {
        "name": "DAD (Double Add - Add pair to HL)",
        "opcode_base": "00RP1001",
        "example_opcode": "09 (DAD B) = 00001001₂",
        "size": 1,
        "cycles": {"any": 10},
        "flags": "CY (only carry)",
        "description": "Add register pair to HL",
        "syntax": "DAD pair",
        "example": "DAD B       ; HL = HL + BC\nDAD H       ; HL = HL + HL (double HL)",
        "notes": "Only CY flag affected. 16-bit addition",
        "related": ["ADD", "INX"],
    },
    "DAA": {
        "name": "DAA (Decimal Adjust Accumulator)",
        "opcode_base": "00100111",
        "example_opcode": "27 = 00100111₂",
        "size": 1,
        "cycles": {"any": 4},
        "flags": "S, Z, AC, P, CY",
        "description": "Adjust accumulator for BCD arithmetic",
        "syntax": "DAA",
        "example": "DAA         ; Adjust A for BCD",
        "notes": "Use after ADD/ADC for BCD (Binary Coded Decimal) math",
        "related": ["ADD", "ADC"],
    },
    # Logical Instructions
    "XRA": {
        "name": "XRA (Exclusive OR with Accumulator)",
        "opcode_base": "10101SSS",
        "example_opcode": "AF (XRA A) = 10101111₂",
        "size": 1,
        "cycles": {"reg": 4, "mem": 7},
        "flags": "S, Z, P (CY=0, AC=0)",
        "description": "XOR register or memory with accumulator",
        "syntax": "XRA register",
        "example": "XRA A       ; A = 0 (fastest way to clear A)\nXRA B       ; A = A XOR B",
        "notes": "XRA A is the fastest way to zero accumulator (4 cycles)",
        "related": ["XRI", "ANA", "ORA"],
    },
    "ANA": {
        "name": "ANA (AND with Accumulator)",
        "opcode_base": "10100SSS",
        "example_opcode": "A0 (ANA B) = 10100000₂",
        "size": 1,
        "cycles": {"reg": 4, "mem": 7},
        "flags": "S, Z, P (CY=0, AC=1)",
        "description": "AND register or memory with accumulator",
        "syntax": "ANA register",
        "example": "ANA B       ; A = A AND B\nANA M       ; A = A AND [HL]",
        "notes": "Useful for masking bits. AC always set to 1",
        "related": ["ANI", "ORA", "XRA"],
    },
    "ORA": {
        "name": "ORA (OR with Accumulator)",
        "opcode_base": "10110SSS",
        "example_opcode": "B0 (ORA B) = 10110000₂",
        "size": 1,
        "cycles": {"reg": 4, "mem": 7},
        "flags": "S, Z, P (CY=0, AC=0)",
        "description": "OR register or memory with accumulator",
        "syntax": "ORA register",
        "example": "ORA B       ; A = A OR B\nORA A       ; Test if A is zero",
        "notes": "ORA A sets flags without changing A",
        "related": ["ORI", "ANA", "XRA"],
    },
    "ANI": {
        "name": "ANI (AND Immediate)",
        "opcode_base": "11100110",
        "example_opcode": "E6 = 11100110₂",
        "size": 2,
        "cycles": {"any": 7},
        "flags": "S, Z, P (CY=0, AC=1)",
        "description": "AND immediate data with accumulator",
        "syntax": "ANI data",
        "example": "ANI 0FH     ; Mask lower 4 bits",
        "notes": "Common for bit masking operations",
        "related": ["ANA", "ORI", "XRI"],
    },
    "ORI": {
        "name": "ORI (OR Immediate)",
        "opcode_base": "11110110",
        "example_opcode": "F6 = 11110110₂",
        "size": 2,
        "cycles": {"any": 7},
        "flags": "S, Z, P (CY=0, AC=0)",
        "description": "OR immediate data with accumulator",
        "syntax": "ORI data",
        "example": "ORI 80H     ; Set bit 7",
        "notes": "Common for setting specific bits",
        "related": ["ORA", "ANI", "XRI"],
    },
    "XRI": {
        "name": "XRI (XOR Immediate)",
        "opcode_base": "11101110",
        "example_opcode": "EE = 11101110₂",
        "size": 2,
        "cycles": {"any": 7},
        "flags": "S, Z, P (CY=0, AC=0)",
        "description": "XOR immediate data with accumulator",
        "syntax": "XRI data",
        "example": "XRI 80H     ; Toggle bit 7",
        "notes": "Common for toggling bits",
        "related": ["XRA", "ANI", "ORI"],
    },
    "CMP": {
        "name": "CMP (Compare with Accumulator)",
        "opcode_base": "10111SSS",
        "example_opcode": "B8 (CMP B) = 10111000₂",
        "size": 1,
        "cycles": {"reg": 4, "mem": 7},
        "flags": "S, Z, AC, P, CY",
        "description": "Compare register with accumulator (A - register)",
        "syntax": "CMP register",
        "example": "CMP B       ; Compare A with B\nJZ EQUAL    ; Jump if A == B",
        "notes": "Sets flags like SUB but doesn't change A",
        "related": ["CPI", "SUB"],
    },
    "CPI": {
        "name": "CPI (Compare Immediate)",
        "opcode_base": "11111110",
        "example_opcode": "FE = 11111110₂",
        "size": 2,
        "cycles": {"any": 7},
        "flags": "S, Z, AC, P, CY",
        "description": "Compare immediate data with accumulator",
        "syntax": "CPI data",
        "example": "CPI 05H     ; Compare A with 05H\nJZ MATCH    ; Jump if equal",
        "notes": "Common for checking specific values",
        "related": ["CMP", "SUI"],
    },
    "RLC": {
        "name": "RLC (Rotate Left Circular)",
        "opcode_base": "00000111",
        "example_opcode": "07 = 00000111₂",
        "size": 1,
        "cycles": {"any": 4},
        "flags": "CY only",
        "description": "Rotate accumulator left, bit 7 to bit 0 and CY",
        "syntax": "RLC",
        "example": "RLC         ; A7→A0, A7→CY",
        "notes": "Fast bit manipulation (4 cycles)",
        "related": ["RAL", "RRC", "RAR"],
    },
    "RRC": {
        "name": "RRC (Rotate Right Circular)",
        "opcode_base": "00001111",
        "example_opcode": "0F = 00001111₂",
        "size": 1,
        "cycles": {"any": 4},
        "flags": "CY only",
        "description": "Rotate accumulator right, bit 0 to bit 7 and CY",
        "syntax": "RRC",
        "example": "RRC         ; A0→A7, A0→CY",
        "notes": "Fast bit manipulation (4 cycles)",
        "related": ["RAR", "RLC", "RAL"],
    },
    "RAL": {
        "name": "RAL (Rotate Left through Carry)",
        "opcode_base": "00010111",
        "example_opcode": "17 = 00010111₂",
        "size": 1,
        "cycles": {"any": 4},
        "flags": "CY only",
        "description": "Rotate accumulator left through carry",
        "syntax": "RAL",
        "example": "RAL         ; A7→CY, CY→A0",
        "notes": "Used for multi-byte shifts",
        "related": ["RLC", "RAR", "RRC"],
    },
    "RAR": {
        "name": "RAR (Rotate Right through Carry)",
        "opcode_base": "00011111",
        "example_opcode": "1F = 00011111₂",
        "size": 1,
        "cycles": {"any": 4},
        "flags": "CY only",
        "description": "Rotate accumulator right through carry",
        "syntax": "RAR",
        "example": "RAR         ; A0→CY, CY→A7",
        "notes": "Used for multi-byte shifts",
        "related": ["RRC", "RAL", "RLC"],
    },
    "CMA": {
        "name": "CMA (Complement Accumulator)",
        "opcode_base": "00101111",
        "example_opcode": "2F = 00101111₂",
        "size": 1,
        "cycles": {"any": 4},
        "flags": "None",
        "description": "Complement (invert) all bits in accumulator",
        "syntax": "CMA",
        "example": "CMA         ; A = ~A (ones complement)",
        "notes": "No flags affected. Inverts all bits",
        "related": ["CMC", "STC"],
    },
    "CMC": {
        "name": "CMC (Complement Carry)",
        "opcode_base": "00111111",
        "example_opcode": "3F = 00111111₂",
        "size": 1,
        "cycles": {"any": 4},
        "flags": "CY (complemented)",
        "description": "Complement the carry flag",
        "syntax": "CMC",
        "example": "CMC         ; CY = ~CY",
        "notes": "Toggle carry flag",
        "related": ["STC", "CMA"],
    },
    "STC": {
        "name": "STC (Set Carry)",
        "opcode_base": "00110111",
        "example_opcode": "37 = 00110111₂",
        "size": 1,
        "cycles": {"any": 4},
        "flags": "CY = 1",
        "description": "Set the carry flag to 1",
        "syntax": "STC",
        "example": "STC         ; CY = 1",
        "notes": "Used to preset carry for rotations or arithmetic",
        "related": ["CMC", "CMA"],
    },
    # Branch Instructions
    "JMP": {
        "name": "JMP (Unconditional Jump)",
        "opcode_base": "11000011",
        "example_opcode": "C3 = 11000011₂",
        "size": 3,
        "cycles": {"any": 10},
        "flags": "None",
        "description": "Jump to 16-bit address unconditionally",
        "syntax": "JMP address",
        "example": "JMP 0800H   ; PC = 0800H\nJMP START   ; PC = START label",
        "notes": "Program counter loaded with new address",
        "related": ["JZ", "JNZ", "CALL"],
    },
    "JNZ": {
        "name": "JNZ (Jump if Not Zero)",
        "opcode_base": "11000010",
        "example_opcode": "C2 = 11000010₂",
        "size": 3,
        "cycles": {"taken": 10, "not_taken": 7},
        "flags": "None",
        "description": "Jump to address if Zero flag is 0",
        "syntax": "JNZ address",
        "example": "DCR B\nJNZ LOOP    ; Jump if B != 0",
        "notes": "Common for loop counters. 10T if jump, 7T if not",
        "related": ["JZ", "JMP", "CMP"],
    },
    "JZ": {
        "name": "JZ (Jump if Zero)",
        "opcode_base": "11001010",
        "example_opcode": "CA = 11001010₂",
        "size": 3,
        "cycles": {"taken": 10, "not_taken": 7},
        "flags": "None",
        "description": "Jump to address if Zero flag is 1",
        "syntax": "JZ address",
        "example": "CMP B\nJZ EQUAL    ; Jump if A == B",
        "notes": "Used after compare or arithmetic. 10T if jump, 7T if not",
        "related": ["JNZ", "JMP", "CMP"],
    },
    "JC": {
        "name": "JC (Jump if Carry)",
        "opcode_base": "11011010",
        "example_opcode": "DA = 11011010₂",
        "size": 3,
        "cycles": {"taken": 10, "not_taken": 7},
        "flags": "None",
        "description": "Jump to address if Carry flag is 1",
        "syntax": "JC address",
        "example": "ADD B\nJC OVERFLOW ; Jump if carry occurred",
        "notes": "Used to detect overflow in addition",
        "related": ["JNC", "JMP"],
    },
    "JNC": {
        "name": "JNC (Jump if No Carry)",
        "opcode_base": "11010010",
        "example_opcode": "D2 = 11010010₂",
        "size": 3,
        "cycles": {"taken": 10, "not_taken": 7},
        "flags": "None",
        "description": "Jump to address if Carry flag is 0",
        "syntax": "JNC address",
        "example": "SUB B\nJNC NO_BORROW",
        "notes": "Used to check no borrow in subtraction",
        "related": ["JC", "JMP"],
    },
    "JP": {
        "name": "JP (Jump if Positive)",
        "opcode_base": "11110010",
        "example_opcode": "F2 = 11110010₂",
        "size": 3,
        "cycles": {"taken": 10, "not_taken": 7},
        "flags": "None",
        "description": "Jump to address if Sign flag is 0 (positive)",
        "syntax": "JP address",
        "example": "SUB B\nJP POSITIVE  ; Jump if result >= 0",
        "notes": "S=0 means positive (bit 7 = 0)",
        "related": ["JM", "JMP"],
    },
    "JM": {
        "name": "JM (Jump if Minus)",
        "opcode_base": "11111010",
        "example_opcode": "FA = 11111010₂",
        "size": 3,
        "cycles": {"taken": 10, "not_taken": 7},
        "flags": "None",
        "description": "Jump to address if Sign flag is 1 (negative)",
        "syntax": "JM address",
        "example": "SUB B\nJM NEGATIVE  ; Jump if result < 0",
        "notes": "S=1 means negative (bit 7 = 1)",
        "related": ["JP", "JMP"],
    },
    "JPE": {
        "name": "JPE (Jump if Parity Even)",
        "opcode_base": "11101010",
        "example_opcode": "EA = 11101010₂",
        "size": 3,
        "cycles": {"taken": 10, "not_taken": 7},
        "flags": "None",
        "description": "Jump if Parity flag is 1 (even parity)",
        "syntax": "JPE address",
        "example": "XRA B\nJPE EVEN_BITS",
        "notes": "P=1 means even number of 1 bits",
        "related": ["JPO", "JMP"],
    },
    "JPO": {
        "name": "JPO (Jump if Parity Odd)",
        "opcode_base": "11100010",
        "example_opcode": "E2 = 11100010₂",
        "size": 3,
        "cycles": {"taken": 10, "not_taken": 7},
        "flags": "None",
        "description": "Jump if Parity flag is 0 (odd parity)",
        "syntax": "JPO address",
        "example": "ANA B\nJPO ODD_BITS",
        "notes": "P=0 means odd number of 1 bits",
        "related": ["JPE", "JMP"],
    },
    "CALL": {
        "name": "CALL (Call Subroutine)",
        "opcode_base": "11001101",
        "example_opcode": "CD = 11001101₂",
        "size": 3,
        "cycles": {"any": 18},
        "flags": "None",
        "description": "Push return address and jump to subroutine",
        "syntax": "CALL address",
        "example": "CALL DELAY\nCALL MULTIPLY",
        "notes": "Return address pushed to stack. Use RET to return",
        "related": ["RET", "JMP", "PUSH"],
    },
    "RET": {
        "name": "RET (Return from Subroutine)",
        "opcode_base": "11001001",
        "example_opcode": "C9 = 11001001₂",
        "size": 1,
        "cycles": {"any": 10},
        "flags": "None",
        "description": "Pop return address and jump to it",
        "syntax": "RET",
        "example": "RET         ; Return to caller",
        "notes": "Pops PC from stack. Must match CALL",
        "related": ["CALL", "POP"],
    },
    "RC": {
        "name": "RC (Return if Carry)",
        "opcode_base": "11011000",
        "example_opcode": "D8 = 11011000₂",
        "size": 1,
        "cycles": {"taken": 12, "not_taken": 6},
        "flags": "None",
        "description": "Return if Carry flag is 1",
        "syntax": "RC",
        "example": "RC          ; Return if CY=1",
        "notes": "Conditional return (12T if return, 6T if not)",
        "related": ["RNC", "RET", "JC"],
    },
    "RNC": {
        "name": "RNC (Return if No Carry)",
        "opcode_base": "11010000",
        "example_opcode": "D0 = 11010000₂",
        "size": 1,
        "cycles": {"taken": 12, "not_taken": 6},
        "flags": "None",
        "description": "Return if Carry flag is 0",
        "syntax": "RNC",
        "example": "RNC         ; Return if CY=0",
        "notes": "Conditional return (12T if return, 6T if not)",
        "related": ["RC", "RET", "JNC"],
    },
    "RZ": {
        "name": "RZ (Return if Zero)",
        "opcode_base": "11001000",
        "example_opcode": "C8 = 11001000₂",
        "size": 1,
        "cycles": {"taken": 12, "not_taken": 6},
        "flags": "None",
        "description": "Return if Zero flag is 1",
        "syntax": "RZ",
        "example": "RZ          ; Return if Z=1",
        "notes": "Conditional return (12T if return, 6T if not)",
        "related": ["RNZ", "RET", "JZ"],
    },
    "RNZ": {
        "name": "RNZ (Return if Not Zero)",
        "opcode_base": "11000000",
        "example_opcode": "C0 = 11000000₂",
        "size": 1,
        "cycles": {"taken": 12, "not_taken": 6},
        "flags": "None",
        "description": "Return if Zero flag is 0",
        "syntax": "RNZ",
        "example": "RNZ         ; Return if Z=0",
        "notes": "Conditional return (12T if return, 6T if not)",
        "related": ["RZ", "RET", "JNZ"],
    },
    "RM": {
        "name": "RM (Return if Minus)",
        "opcode_base": "11111000",
        "example_opcode": "F8 = 11111000₂",
        "size": 1,
        "cycles": {"taken": 12, "not_taken": 6},
        "flags": "None",
        "description": "Return if Sign flag is 1",
        "syntax": "RM",
        "example": "RM          ; Return if S=1",
        "notes": "Conditional return (12T if return, 6T if not)",
        "related": ["RP", "RET", "JM"],
    },
    "RP": {
        "name": "RP (Return if Positive)",
        "opcode_base": "11110000",
        "example_opcode": "F0 = 11110000₂",
        "size": 1,
        "cycles": {"taken": 12, "not_taken": 6},
        "flags": "None",
        "description": "Return if Sign flag is 0",
        "syntax": "RP",
        "example": "RP          ; Return if S=0",
        "notes": "Conditional return (12T if return, 6T if not)",
        "related": ["RM", "RET", "JP"],
    },
    "RPE": {
        "name": "RPE (Return if Parity Even)",
        "opcode_base": "11101000",
        "example_opcode": "E8 = 11101000₂",
        "size": 1,
        "cycles": {"taken": 12, "not_taken": 6},
        "flags": "None",
        "description": "Return if Parity flag is 1",
        "syntax": "RPE",
        "example": "RPE         ; Return if P=1",
        "notes": "Conditional return (12T if return, 6T if not)",
        "related": ["RPO", "RET", "JPE"],
    },
    "RPO": {
        "name": "RPO (Return if Parity Odd)",
        "opcode_base": "11100000",
        "example_opcode": "E0 = 11100000₂",
        "size": 1,
        "cycles": {"taken": 12, "not_taken": 6},
        "flags": "None",
        "description": "Return if Parity flag is 0",
        "syntax": "RPO",
        "example": "RPO         ; Return if P=0",
        "notes": "Conditional return (12T if return, 6T if not)",
        "related": ["RPE", "RET", "JPO"],
    },
    "RST": {
        "name": "RST (Restart - Call Fixed Address)",
        "opcode_base": "11NNN111",
        "example_opcode": "C7 (RST 0) = 11000111₂",
        "size": 1,
        "cycles": {"any": 12},
        "flags": "None",
        "description": "Call subroutine at fixed address (N * 8)",
        "syntax": "RST n (n=0-7)",
        "example": "RST 0       ; CALL 0000H\nRST 5       ; CALL 0028H",
        "notes": "Fast subroutine call to 8 fixed addresses (0, 8, 10H, 18H, 20H, 28H, 30H, 38H)",
        "related": ["CALL", "RET"],
    },
    "IN": {
        "name": "IN (Input from Port)",
        "opcode_base": "11011011",
        "example_opcode": "DB = 11011011₂",
        "size": 2,
        "cycles": {"any": 10},
        "flags": "None",
        "description": "Read byte from I/O port into accumulator",
        "syntax": "IN port",
        "example": "IN 01H      ; A = Port[01H]\nIN 10H      ; A = Port[10H]",
        "notes": "Port address in byte 2. Used for hardware I/O",
        "related": ["OUT"],
    },
    "OUT": {
        "name": "OUT (Output to Port)",
        "opcode_base": "11010011",
        "example_opcode": "D3 = 11010011₂",
        "size": 2,
        "cycles": {"any": 10},
        "flags": "None",
        "description": "Write accumulator to I/O port",
        "syntax": "OUT port",
        "example": "OUT 01H     ; Port[01H] = A\nOUT 10H     ; Port[10H] = A",
        "notes": "Port address in byte 2. Used for hardware I/O",
        "related": ["IN"],
    },
    "EI": {
        "name": "EI (Enable Interrupts)",
        "opcode_base": "11111011",
        "example_opcode": "FB = 11111011₂",
        "size": 1,
        "cycles": {"any": 4},
        "flags": "None (enables INTE)",
        "description": "Enable interrupt system",
        "syntax": "EI",
        "example": "EI          ; Enable interrupts",
        "notes": "Allows CPU to respond to interrupt requests",
        "related": ["DI", "RIM", "SIM"],
    },
    "DI": {
        "name": "DI (Disable Interrupts)",
        "opcode_base": "11110011",
        "example_opcode": "F3 = 11110011₂",
        "size": 1,
        "cycles": {"any": 4},
        "flags": "None (disables INTE)",
        "description": "Disable interrupt system",
        "syntax": "DI",
        "example": "DI          ; Disable interrupts",
        "notes": "Prevents CPU from responding to interrupts",
        "related": ["EI", "RIM", "SIM"],
    },
    # Stack Instructions
    "PUSH": {
        "name": "PUSH (Push Register Pair to Stack)",
        "opcode_base": "11RP0101",
        "example_opcode": "C5 (PUSH B) = 11000101₂",
        "size": 1,
        "cycles": {"any": 12},
        "flags": "None",
        "description": "Push register pair onto stack",
        "syntax": "PUSH pair",
        "example": "PUSH B      ; [SP-1]=B, [SP-2]=C, SP=SP-2\nPUSH PSW    ; Save A and flags",
        "notes": "High byte pushed first, then low byte. SP decremented by 2",
        "related": ["POP", "CALL"],
    },
    "POP": {
        "name": "POP (Pop Stack to Register Pair)",
        "opcode_base": "11RP0001",
        "example_opcode": "C1 (POP B) = 11000001₂",
        "size": 1,
        "cycles": {"any": 10},
        "flags": "None (PSW restores all flags)",
        "description": "Pop stack to register pair",
        "syntax": "POP pair",
        "example": "POP B       ; C=[SP], B=[SP+1], SP=SP+2\nPOP PSW     ; Restore A and flags",
        "notes": "Low byte popped first, then high byte. SP incremented by 2",
        "related": ["PUSH", "RET"],
    },
    # Special Instructions
    "HLT": {
        "name": "HLT (Halt)",
        "opcode_base": "01110110",
        "example_opcode": "76 = 01110110₂",
        "size": 1,
        "cycles": {"any": 5},
        "flags": "None",
        "description": "Halt program execution",
        "syntax": "HLT",
        "example": "HLT         ; Stop CPU",
        "notes": "CPU stops until RESET or interrupt. Same encoding as MOV M, M",
        "related": ["NOP"],
    },
    "NOP": {
        "name": "NOP (No Operation)",
        "opcode_base": "00000000",
        "example_opcode": "00 = 00000000₂",
        "size": 1,
        "cycles": {"any": 4},
        "flags": "None",
        "description": "No operation - do nothing for one cycle",
        "syntax": "NOP",
        "example": "NOP         ; Delay 4 T-states\nNOP         ; Used for timing",
        "notes": "Useful for timing delays or placeholders",
        "related": ["HLT"],
    },
}